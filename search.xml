<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法学习-划分树]]></title>
    <url>%2F2018%2F04%2F15%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%92%E5%88%86%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前两天在白书上学习了归并树， 是用了线段树+归并排序的思想在$O(log^3 (n))$复杂度下查找区间k大。 今天学习的划分树则可以在$O(log(n))$的复杂度下查找区间第k大。 划分树正好是归并树反过来了， 他用的是线段树+快速排序的思想。 快速排序我们先来复习快速排序的方法： 对于当前要排序的区间， 我们随机找一个数作为基础值， 分别用两个指针l和r 把基础值放在最左边。 r指针先往左移， 碰到一个比基础值小的a[r]， 交换a[r]和基础值， 让l往右移动， 直到碰到一个值[l]比基础值， 交换a[l]和基础值， 重复第二步， 直到l == r. 将基础值左边和右边的区间分别继续快速排序， 直到区间内只有一个值。 划分树划分树就是用线段树记录每一层快速排序的状态， 用sort快速排序作为辅助，将排好序的数组放到sorted[]内， 每次排序区间[l, r]时， 用sorted[(l+r)/2]作为基础值， 这样使得下一层左右两个区间尽长度尽可能相同。 我们用tree[20][n]来记录每一层快速排序的状态， 用toleft[dis][i]记录第dis层前i个值有多少个在下一层进入了左区间。 划分树也分为两部分： 1. 初始化操作对于每一个要排序的区间[l, r]， 将基础值设为sorted[(l+r)/2], 如果值小于基础值则放到下一层的左边， 否则放到下一层的右边区间， 但是这样不能保证左右区间尽可能长度相同， 主要是有很多个值都等于基础值， 这个时候就要将灵活处理一下： 用same记录当前和基础值相同的个数， same初始等于下一层左区间长度， 左区间每放一个小于等于基础值的数， same--， 直到same == 0 的时候， 剩下相等的就只能放到右边区间了。 最后顺便更新有多少个移到了下一层的左区间。 继续递归进行Build操作。 12345678910111213141516171819202122232425262728293031// 初始化区间[l,r]void Build(int dep, int l, int r) &#123; if(l == r) return; int mid = (l + r) &gt;&gt; 1; int same = mid - l + 1; for(int i = l; i &lt;= r; i++) if(tree[dep][i] &lt; sorted[mid]) same--; int lpos = l; int rpos = mid + 1; for(int i = l; i &lt;= r; i++) &#123; if(tree[dep][i] &lt; sorted[mid]) &#123;// 小的值直接放到左儿子 tree[dep + 1][lpos++] = tree[dep][i]; &#125; else if(tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0) &#123; // 左儿子还有空能放相同的数 tree[dep + 1][lpos++] = tree[dep][i]; same--; &#125; else tree[dep + 1][rpos++] = tree[dep][i]; // 剩下的大于等于的放到右儿子 toleft[dep][i] = toleft[dep][l - 1] + lpos - l; // 更新有多少个数放到了左边 &#125; Build(dep + 1, l, mid); Build(dep + 1, mid + 1, r);&#125;void Init() &#123; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); sorted[i] = tree[1][i] = a[i]; &#125; sort(sorted + 1, sorted + n + 1, cmp); Build(1, 1, n);&#125; 2. 查询操作查询[ql, qr]的第k大， 如果当前区间[l, r]下一层往左的个数即toleft[dep][qr]-toleft[dep][ql-1] &gt;= k的话， 说明第k大的数肯定在下一层的左区间， 并且更新查询区间。 newl为 当前的L + (L到ql中去了下一层左区间的个数， 他们不再查询范围内， 要加上）。 newr则为 newl + cnt - 1。 否则的话 说明第k大在下一层的右区间， 同理也需要更新查询区间。 继续查询。 newr为当前的qr 加上qr外面即（qr到R中到了下一层左边的个数）。 newl同理 newr就是往前（查询长度 - 要查询中去了下一层左边的个数）， 同时查询的个数也要减去cnt。 当区间只有一个值的时候， 为第k大， return即可。 1234567891011121314151617// 询问[ql, qr] 中第k大的数 // 外部调用query(1, 1, n, l, r, k);int query(int dep, int L, int R, int ql, int qr, int k) &#123; if(ql == qr) return tree[dep][ql]; int mid = (L + R) &gt;&gt; 1; int cnt = toleft[dep][qr] - toleft[dep][ql - 1]; if(cnt &gt;= k) &#123; int newl = L + toleft[dep][ql - 1] - toleft[dep][L - 1]; int newr = newl + cnt - 1; return query(dep + 1, L, mid, newl, newr, k); &#125; else &#123; int newr = qr + toleft[dep][R] - toleft[dep][qr]; int newl = newr - (qr - ql - cnt); return query(dep + 1, mid + 1, R, newl, newr, k - cnt); &#125;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-归并树]]></title>
    <url>%2F2018%2F04%2F11%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%BD%92%E5%B9%B6%E6%A0%91%2F</url>
    <content type="text"><![CDATA[用一句话定义归并树就是用线段树记录归并排序时每一层每一段数组的状态。 用途： 归并树可以在$O(log(n)^2 )$复杂度查找区间[l,r]比x小的有几个. 那么就可以通过二分枚举在$O(log(n)^3 )$复杂度实现查找区间[l,r]第k大的值. 我们先回顾一下归并排序的具体实现方法： 归并排序依靠递归的思想， 每次把当前要排序的区间分成尽可能相等的两部分， 左右两部分分别进行归并排序， 之后再将排好序的左右两个区间合并。 当区间长度为1的时候， 停止递归。 复杂度分析： 因为每次将当前序列分成两部分递归， 最多分$O(log(n))$层, 每层有n个元素, 所以归并排序的复杂度是$O(nlog(n))$. 归并排序最常用的就是求逆序对的个数， 其实用树状数组也可以在相同的复杂度下求出逆序对。 c++实现代码： 123456789101112131415161718192021//参考紫书算法竞赛入门经典 void merge_sort(int *A, int l, int r, int *T)&#123; //[l, r) 排序. 外部调用区间为[0, n) if(r - l &gt; 1)&#123; int mid = l+(r-l)/2; int p = l, q = mid, now = l; // 对左右两部分区间分别归并排序 merge_sort(A, l, mid, T); merge_sort(A, mid, r, T); // 合并左右两部分 while(p &lt; mid || q &lt; r)&#123; if(q &gt;= r || (p &lt; mid &amp;&amp; A[p] &lt;= A[q]))&#123; T[now++] = A[p++]; &#125; else&#123; T[now++] = A[q++]; cnt += mid - p; // cnt记录的是逆序对个数 &#125; &#125; for(int i = l; i &lt; r; i++) A[i] = T[i]; &#125;&#125; 以上是对归并排序的复习， 下面继续学习归并树。 先说一下归并树的大致思想， 用vector维护出每一个节点的区间[l,r)排完序之后的数组, 每次查询的时候, 分三种情况. 如果要查询的区间和当前的区间没有交集, 返回0个. 如果要查询的区间完全包含了当前的区间， 用二分搜索对于当前节点保存的数组进行查找。 负责的话递归左右儿子查找并且求和。 根据归并排序的思想， 要先初始化归并树， 原理同归并排序， 只不过把数组的值都存起来了， 每次询问的时候， 分上面说的三种情况就可以了。 具体看下面这一道例题以及模板代码。 模板例题： 2104 - K-th Number 123456789101112131415161718192021222324252627282930313233343536373839// 代码参考白书(挑战程序设计竞赛)const int MAXN = 1e5;const int ST_SIZE = (1 &lt;&lt; 18) - 1;int n, m;int a[MAXN+5], num[MAXN+5];// num用来存a排好序之后的数组， 方便二分vector&lt;int&gt; dat[ST_SIZE];// 初始化归并树， 原理和归并排序一样， 区间[l, r)void init(int k, int l, int r)&#123; if(r - l == 1)&#123; dat[k].push_back(a[l]); &#125; else&#123; int lch = k * 2 + 1, rch = k * 2 + 2; init(lch, l, (l+r)/2); init(rch, (l+r)/2, r); dat[k].resize(r-l); merge(dat[lch].begin(), dat[lch].end(), dat[rch].begin(), dat[rch].end(), dat[k].begin()); // 利用STL自带的merge函数把两个儿子的数列合并 &#125;&#125;// 计算[ql, qr) 中不超过x的个数// k是节点的编号, 对应区间[l, r)int query(int ql, int qr, int x, int k, int l, int r)&#123; if(qr &lt;= l || r &lt;= ql)&#123;//完全不相交 return 0; &#125; else if(ql &lt;= l &amp;&amp; r &lt;= qr)&#123; // 询问完全包含当前区间 return upper_bound(dat[k].begin(), dat[k].end(), x) - dat[k].begin(); &#125; else&#123; int lcnt = query(ql, qr, x, k*2+1, l, (l+r)/2); int rcnt = query(ql, qr, x, k*2+2, (l+r)/2, r); return lcnt + rcnt; &#125;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Mac中将chrome商店下载的插件导出为crx]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%9C%A8Mac%E4%B8%AD%E5%B0%86chrome%E5%95%86%E5%BA%97%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%8F%92%E4%BB%B6%E5%AF%BC%E5%87%BA%E4%B8%BAcrx%2F</url>
    <content type="text"><![CDATA[Mac下Chrome的插件保存在~/Library/Application\ Support/Google/Chrome/Default/Extensions/对应ID下。 通过下面两行命令我们可以看到每个插件的命名都是他固定的ID。 也就是在chrome浏览器中扩展程序里显示的ID。 12cd ~/Library/Application\ Support/Google/Chrome/Default/Extensions/ls 12cd 对应插件的IDls 这时候可以看到这个软件的版本， 再cd版本号 12cd 对应版本号pwd 使用pwd显示当前路径， 然后复制该路径。 粘贴到chrome-&gt;扩展程序-&gt;打包扩展程序。点击打包扩展程序这时候.xrc文件就会生成到对应目录下， 结束！]]></content>
      <categories>
        <category>Mac技巧</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>chrome插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[想把博客部署到Coding上? 看完再决定]]></title>
    <url>%2F2018%2F03%2F19%2F%E6%83%B3%E6%8A%8A%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0Coding%E4%B8%8A-%E7%9C%8B%E5%AE%8C%E5%86%8D%E5%86%B3%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[我想大多数人想把博客同时部署到Github和Coding上的目的基本都一样： 加快国内访问速度 能够被百度收录 我主要是奔着被百度收录进来的， 因为Github已经屏蔽了百度的爬虫， 所以想要被百度收录， 只好另寻他路， 网上有人说可以同时部署到gitcafe上， 可是一查， gitcafe早在2016年3月就被Coding并购了, 所以目前最好的办法就是同时部署到Github和Coding上了. 但是!! 但是!! Coding其实也坑的很. 首先Coding分为了四种会员:普通会员、银牌会员、金牌会员和钻石会员。 我想基本上每个人都使用了自己的域名了吧， 第一个坑点就是:你想绑定自己的域名, 必须是银牌会员。这个银牌会员是免费的， 只需要你完善个人信息就可以了。 但是你以为这样就结束了吗？ 并没有， 看官方的介绍说： 银牌会员是受限的pages自定义域名。 金牌及以上才是完全的自定义域名。我们来看看银牌是如何受限的： 银牌会员的 Coding Pages 在访问时默认会先加载 Pages 跳转页，您可选择在网站首页任意位置放置「Hosted by Coding Pages」的文字版或图片版，然后勾选下方的「已放置 Hosted by Coding Pages」选项，通过审核后您的 Pages 将不会显示跳转页。请务必将「Hosted by Coding Pages」持续保留在网站首页，撤掉后跳转页会再次出现。 意思就是说你使用自定义域名可以， 但是先帮我们弹一个页面， (打个广告). 这首先就影响了用户的体验， 并且， 百度爬虫也是爬不到的， 因为第一次访问到的是他的广告页面。并且最近(2018-3-19)我发现跳转的这个页面无法访问了， 所以每当第一次进入博客就会转到coding/404。之后再进一次就是正常的博客了， 但是你只要清除浏览器数据、缓存， 再次登录 又是404。体验更是糟糕。 我才猛的想起来前几天看了一些人的博客打开就是coding的404， 我以为是他们的博客不用了， 现在想想原来是coding搞的鬼。 当然coding显然意识到了这样体验实在是太差了， 当然有别的选择， 在你的博客上帮他打广告！ 只要你在博客首页放上coding要求的文字或者图片并且通过审核， 就可以不用页面跳转了。 我今天刚刚提交申请， 说是在两个工作日完成审核。 我文字放在了最下面： 第二天更新：我是昨天下午提交审核的， 今天早晨下课一看已经通过审核了。 可以通过Coding正常访问了， 不会跳出中转页面。 紧接着我就去阿里云设置dns， 将github的设置为境外， coding为默认。 然后去了站长工具dns检测 。 可以看出大陆的都是通过coding访问的， 国外的是通过github访问的。 当然我最关心的问题还是百度收录的问题，去百度平台看了一下， 发现之前提交的站点地图在昨晚11点半的时候竟然有抓取记录， 不懂这是在干嘛， 百度搜了一下我的域名还是搜不到， 又去抓取诊断里试了一下， 咦！ 竟然能被抓取到了。但是试了几次不是百分百成功。 网上都说被百度收录是一个漫长的过程， 那我就先慢慢等待。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客遇到的坑]]></title>
    <url>%2F2018%2F03%2F11%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[待解决问题首页预览行数控制问题。配置第三方服务。 （评论， 数量统计之类的)是否能把csdn的博客迁过来。 （不打算搬了， 分开写不同的东西）about页面的一些美化让百度google能够搜索 （谷歌已经解决， 百度貌似被github屏蔽了）每一篇文章阅读量多台电脑管理博客， 参考博客共同管理站点让文章可以置顶 已解决问题 侧栏链接图标配不上去问题&#160; &#160; 教程中说的是 在主题配置文件中的social_icons中添加网站的名称, 但是试了很多次都不成功.&#160; &#160; 解决办法: 发现在social也就是贴链接的位置 后面默认会有两个竖杠|| , 正确做法是在||后面粘贴图片的名字. 12345social: GitHub: https://github.com/ZZZZone || github 微博: http://weibo.com/_ZZZZone || weibo 知乎: http://www.zhihu.com/people/zzzzone-87 || bolt codeforces: http://codeforces.com/profile/ZZZZone || fort-awesome mathjax渲染问题更新， 请不要使用删除线中的方法 &#160; &#160; 网上找了很多方法, 不停地uninstall,install, 已经忘记了hexo默认给的是什么软件渲染的了.&#160; &#160; 最后使用的是markdown-it, 虽然在next主题的TOC显示上面会有一些问题, 牺牲一下吧. 毕竟写题解的时候公式很重要。 暂时先使用这种方法。markdown-it &#160; &#160; 之前一直使用的是markdown-it, 问题就是TOC有问题并且在主页无法使用&lt;!-- more --&gt;来设置阅读全文.&#160; &#160; 解决方法: 经过一番搜索, 发现了另一个软件, 叫hexo-renderer-kramed，完美解决了这个问题。参考博客: 林肯先生的blog。 具体做法这篇博客已经详细介绍了。 评论插件在尝试了gitment和来必力之后, 我选择了来必力. 使用比较简单， 因为gitment我没有解决issue过长导致异常的问题。 而且gitment只能使用github账号登陆， 对于我这种基本没有评论的人来说被评论的机会就更小了， 所以最终选择了来必力。使用法法: 在来必力官网注册一下， 因为我是用的是next5.1.4版本， 配置中已经集成了许多插件， 不需要自己再去修改文件了， 只求要去改一改配置就行了。 在主题目录中的配置文件搜索livere_uid: 在这里填上你申请的来必力代码中有一串ID， 就可以了。 更新： 把来必力换掉了。 换成Valine了， 更简约， 使用起来更方便。 使用的跟文章浏览人数同样的管理平台， 数据管理起来也比较方便。 可以到next主题目录下的配置文件中的valine写好对应的id和key就可以了。 具体教程参考： valine官方文档 文章阅读量显示这个很好弄， 照着教程解决就可以了链接在此 使用自己的域名在阿里云上1块钱一年的.top域名。 觉得很实惠， 就买了一个。 按照百度上的做法配置了域名之后， 发现只能用chrome浏览器访问， 手机和电脑都是。 电脑用Safari找不到服务器， 手机用了via浏览器一直显示dnserror， 百度了一下说是DNS劫持？ 果断把电脑了DNS从114.114.114.114换回了默认， 手机浏览器清了一下cookie什么的， 解决。 所有浏览器正常访问。 博文置顶🔝github上有这样的仓库了，原仓库替换了hexo自带的置顶， 挺好用的。 执行下面两行命令： 12$ npm uninstall hexo-generator-index --save $ npm install hexo-generator-index-pin-top --save 之后只需要在文章的front-matter中添加top: ture就可以将博文置顶了。后来我又发现， 使用top: 数值 会按数值降序置顶排序。 next主题支持在front-matter中添加sticky: true来显示置顶标志（一个小Pin）。 将博客部署到coding 上参考博客Hexo博客部署到GitHub和Coding我部署到coding上主要是为了解决百度无法爬去github。首先是在coding上注册账号， 然后创建一个工程， 工程名称和你的用户名一样， 避免css之后渲染出问题。给coding配置ssh秘钥。 在终端中执行ssh -T git@git.coding.net 检验是否配置成功。然后在站点的配置文件 _config.yml 中添加coding的ssh路径. 仿照github中的方法配置。然后执行 三命令， 就可以将博客部署到coding上。去阿里云修改dsn解析。 将之前github的dsn 修改为海外 。 然后再添加coding。最后再去coding的仓库pages服务， 添加静态pages。 并添加自定义域名。 我手动添加了zzzzone.top和www.zzzzone.top两个域名。 最后我在/Users/zong/Documents/hexo/themes/next/layout/_partials中]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试一下一下博客， 先贴一个题解。]]></title>
    <url>%2F2018%2F03%2F09%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAgithub%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[题目链接Non-decreasing 题目大意给一个长度为$n\ (1 \leq n \leq 50)$的序列。 每次可以选择两个数$a_x, a_y$, 把$a_x$加到$a_y$上。最终使得a序列不递降， 题目保证0~2n次有解。 输出操作个数以及操作方案。 $test markdown $ 数据范围$1 \leq n \leq 50$$-10^6 \leq a_i \leq 10^6$ 解题思路这道题比赛的时候没想出来。C题5分钟写完就挂机了。。 比赛完了之后看了别的代码瞬间理解。其实如果这个题$a_i$全是正数或者全是负数, 应该都能想到从左往右或者从右到左累加一次, 即操作了n-1次, 就符合条件了.但是现在有正有负, 又不难发现, 只需要记录绝对值最大的数, 把这n个数都加上这个绝对值最大的数, 他们就符号统一了, 这个操作为n次, 所以题目才能保证在 2n次肯定有解. AC代码1234567891011121314151617181920212223242526272829/******************************************** *Author* :ZZZZone *Created Time* : 一 12/11 20:46:20 2017 * Ended Time* : 一 12/11 21:04:29 2017*********************************************/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;int n;int a[55];int main()&#123; scanf("%d", &amp;n); int p = 0; for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;a[i]); if(abs(a[i]) &gt;= abs(a[p])) p = i; &#125; printf("%d\n", 2 * n - 1); for(int i = 1; i &lt;= n; i++) printf("%d %d\n", p, i); if(a[p] &gt; 0) for(int i = 1; i &lt; n; i++) printf("%d %d\n", i, i + 1); else for(int i = n; i &gt; 1; i--) printf("%d %d\n", i, i - 1); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
