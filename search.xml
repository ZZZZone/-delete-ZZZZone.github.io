<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决javaFX import报错]]></title>
    <url>%2F2018%2F05%2F16%2F%E8%A7%A3%E5%86%B3javaFX-import%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[今天在机房电脑用eclipse和自己电脑的eclipse写javaFX的时候， 在import javafx.application.Application;之后都出现了报错。 解决方法： Project -&gt; Properties -&gt; libraries，先 remove 掉 JRE System Library，然后再 Add Library 重新加入。 原因：eclipse默认的jre是不会指定jfxrt.jar的，只能手工添加。所以需要重新手动导入JRE。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>解决问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim操作命令学习整理]]></title>
    <url>%2F2018%2F05%2F15%2Fvim%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[日常记录容易忘记的Vim指令 首先是这两个符号： ^表示行的开头。 $表示行尾。 这样可以通过:num1,num2s/old/new/g的替换命令实现快速在多行行首和行尾插入。 比如在cpp文件中想在1到5行添加//进行注释， 那么命令就是 1:1,5s/^/\/\//g 因为\符号需要转义， 所以连个\\的注释需要写成\/\/. 当然我们也可以通过命令快速取消注释 1:1,5s/^\/\///g 也可以使用shift+V快速选中多行在视图模式下直接按:, 会自动补全:&#39;&lt;,&#39;&gt; 这时候只需要输入后面的命令就可以实现将选中的行进行快速操作。 快速注释已选中的行： 1:'&lt;,'&gt;s/^/\/\//g 快速取消注释 其实以上几条命令不加后面的/g效果也是一样的, 因为每一行只有最开头有一个^符号。 比如下面这样 取消选中行的注释 1:'&lt;,'&gt;s/^\/\/]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-5-8组队训练总结]]></title>
    <url>%2F2018%2F05%2F12%2F2018-5-8%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天的训练赛题目是2017 Benelux Algorithm Programming Contest (BAPC 17). 总的来说打的非常挫， 比赛的时候只过了三道题，主要是我的失误， D题题意读错， I题规律推挫了， 导致卡题从头卡到尾， 跟去年西安区域赛的感觉非常像了。 如果不卡题的话正常来说是可以过6~7题。 比赛前一个小时因为要去听一个讲座， 迟到了一个小时， 等我来的时候， TRDD和大佬已经过了F和A题。来了之后我先读了K题。 K题题意: 有n个人 编号0~n-1 $(1 \le n \le 1000)$, 之后给一个n*n的矩阵a， $a[i][j]$ 有三种符号0 1 X。 0表示i会输给j, 1 表示i赢j, X表示自己。 现在让你给这n个人安排一个比赛顺序， 第一个人默认是擂台主， 第一个先跟第二个打， 谁赢了谁成为擂主， 擂主再跟第三个人打… 以此类推， 现在你想让0号选手赢， 让输出这样一个序列， 如果不行， 输出impossible。 刚开始大佬想到用DFS找到一个长度为n的序列， 然后输出， 我觉得这样肯定会TLE， 就否定了大佬， 然后又仔细想了一下， 突然想到， 只要跑出一个BFS序就可以了， 对于第i层， 不管第i+1层的人怎么安排， 肯定第i层的人会胜利。 所以只需要以0号点跑BFS， 看是否能跑出n个点就可以了。 在1h54分的时候过了K， 之后的三个小时， 我们就卡题卡到绝望。 紧接着我读的I， TRDD读的D， 但是这两道题的题意都不是很好理解。 I题题意: 给一个n*m的黑白相间的巧克力， 左上角是黑色的， A和B两个人分别切巧克力， A可以从左边选择往右选择任意长度的列且给自己， B可以从下往上切任意长度的行给自己， 每次切完后自己获得黑个数-白个数的分数。 现在A想让他俩分数的差值尽可能大， 问最大差值能有多大。 这个题我一直被中间的某一段迷惑， 因为文中有提到两个人都想获得尽可能多的黑巧克力， 然而这个信息是没有用的， 我却往这个方向走偏了。刚开始我发现n为偶数的时候肯定是0， n和m都是奇数的时候答案为1， n为奇数m为偶数， 我刚开始直接输出2 。 Wa28组， 后来怎么改都改不过。。。。 到最后学弟告诉我需要判断一下n和m的大小 n &gt; m是0 n &lt; m是2。。。。难受 找不出这个规律。 然后是D题，，， 也是题意读错了， 导致大佬写的最短路Wa3找不出错感到绝望。正确的题意是这样的： D题题意: 给一个n个点$1 \le n \le 10^5 $编号从0开始, m条边$1\le m \le 10^6$的无向图， 现在你要做大巴从0号点到1号点， 但是发现大巴不会走有路标指向的道路（意思是路标是有方向的）。 让你输出一条大巴走的路线。定义： 如果当前这个点走这条边是到达1号点的最短路径， 那么这条路的方向就会被放上路标。 解题思路： 正解是从1号点开始用Dijstra跑一遍最短路求得每一个点到一号点的最短距离。 然后再跑一遍BFS删掉（标记）哪些边是有路标的边， 之后再从0号点跑一遍BFS输出即可。 比赛当时这道题题意理解挫了， 以为只有0到1的最短路不能走， 然后标记上跑一个BFS， 死活不对， 比赛结束之后问了学长才明白题意。 卡题的这三个小时， 我们没读其他题， 其实如果开其他题的话L题是可做的， 思路很好像， E题应该也可做， 以大佬的脑力解决没问题。 但是。。。 我没压根就没读题。。。。这场比赛就以三题结束了。。 L题和E题先挖坑。。。 有空在写。]]></content>
      <categories>
        <category>训练总结</category>
      </categories>
      <tags>
        <tag>训练总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-5-5组队训练总结]]></title>
    <url>%2F2018%2F05%2F07%2F2018-5-5%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天打得题是SWERC 2017西欧区域赛的题目， 一共过了4道题， 分别是A， E， F， J。 最后卡了K没过。 模拟现场榜单的话排31， 大概是铜上游的位置吧。 过程首先上来我先读的C题， 题意比较短， 但最后发现是个很难的题， C题目大意： 给一个$n \times m $ 的矩阵，$(1\le n \le 8, 1\le m \le 10^ {18})$ 让你用$1\times1$ 或者$1\times2$或者$2\times1$的方格全部铺满， 不能覆盖， 问方案数模$10^ 9$ 题还没读完的时候， 发现F是道水题， 4分钟的时候有三个一血。。 正好TRDD在读F， 所以我就继续看C。TR跟大佬叙述了题意之后， 应该是没太理清题意， 大佬思考了一下发现题目并不简单， 甩给我又重读了一遍， 发现漏了一个重要条件（就是n个矩形是由大的$W \times L$分出来的）。 F题目大意： 一个$W \times L\ \ (1 \le W, L \le 10\ 000)$的矩形被分成了n$(1 \le n \le 5\ 000\ 000)$块小矩形， 这n个矩形的长宽分别为$w_i, l_i (1\le w_i, l_i \le 10\ 000)$. 给定W， 输出L。 F题在19分钟过的。 这时候许多队已经过了F了， 而且安神也已经两题了。 大佬在写F的时候， 我瞅了一眼榜， 发现J题有人过， 并且题意很好懂， 大佬写完F后立刻跟大佬说了题意， 大佬也秒想出了做法。 开始敲起。 J题大意： 把一个大矩阵横着分成n段每段的长度为$a_i $， 竖着分成n段， 每段的长度为$b_i $， 现在有三种颜色 0、 1、 2。 对于第$[i, j]$块， 他被涂成$(i+j) \% 3$的颜色， 最后问0 1 2 三种颜色分别的面积是多少。 在第26分钟， 过了J题， 算一算， 从大佬过了F题到过了J题用了7分钟， 总的来说这题过的还是很顺利的。 这时候看了一下榜单， A题第三容易的题， TRDD在读A， 我问他咋样， 他把题面甩给我一看， 题目巨长， 让我读吧， 在读A之前我趁这个空把C题的题意跟大佬说了一把， 虽然没人过， 总比大佬挂机没有题想要好。这个时候E和K都有人过， 让TRDD随便挑一题去读， 挑了个K。A题虽然题目长， 但是整体思路比较好懂， 很快就读完了， 并跟大佬叙述了题意。 A题大意： 有一个烤箱， 有一个入口一个出口， 现在在入口和出口各放一个检测器， 蛋糕通过时会做记录， 烘焙蛋糕的时间是一个定值， 现在这个检测器有些毛病， 没蛋糕通过他可能会记录， 有蛋糕通过他也可能不记录， 现在给你两个长度为n和m$1\le n, m \le 2\ 000$的数组， 第一个数组是入口检测器监测到有蛋糕的时间， 第二个数组是监测到有蛋糕经过出口的时间，时间$0\le t \le 10 ^9$ 当然这连个数组的时间不准确， 现在让你猜测最完美烘焙时间是多长， 使得完美烘焙的蛋糕数量尽可能多。输出你猜测的最佳烘焙时间，如果有多个， 输出小的。 但是叙述完题意之后我和大佬都感到疑惑， 题目真的是这个意思么？ 那也太水了吧， 暴力一搞就出来了， 为了以防万一， 我让大佬先写着， 我再读一遍确定一下题意， 发现还是这个题意， 便让大佬交了一发， 然后A题就一脸懵逼的过了。 这时候只有E和K暂时来看是可做的， 然后我选择了题目巨长的E， TRDD读K。 题目太难叙述了。。。 不想写了。 👻 E题题意确实有些繁琐， 以至于我读懂之后跟大佬叙述题意的时候我俩思维就没在一个频道上， 他说了一下他的解法之后我也没太注意。 导致了大佬写完之后样例过不去， 经过我再一次讲解题意， 发现后面基本写偏了， 还好刚开始建树求每种pizza的思路是对的。 经过讨论之后发现是一个01背包， 这时候大佬作为惩罚让我写01背包， 他去趟厕所， DP巨挫的我有点慌张， 让谭瑞来在旁边看着我写的对不对， 然而！！ 还是写挫了。。。。 大佬从厕所回来后发现我还没有AC把我赶下了机位。。。 改了几下，交上去，TLE了！ 想了一下， n^2 的背包应该不会T。 应该是因为用cin读字符串来导致的， 然后我建议大佬用scanf读进来再塞到string中取， 然后交上去AC了。 这时候TRDD跟我和大佬说了一下K题的题意， 一道几何题。 K题大意： 给一个半径为R的蛋糕（基本没用）， 给n个点表示蜡烛， 每个蜡烛坐标$x_i, y_i $， 现在让你一次吹灭所有的蜡烛， 吹风的横截面最小是多少。 平时很少做几何的题， 刚开始想肯定需要先求个凸包， 然后再在凸包上瞎搞一搞， 然后我想到了先求出第一条边最远的点在哪， 然后逆时针移动边的时候， 点也是跟着逆时针移动的， 可以在$O(n)$复杂度下求解， 后来我才知道这个算法(思路)是旋转卡壳。。。 大佬想了一下， 觉着没什么问题， 就让TRDD抄凸包的板子， 我在旁边整理如何求解。后来TRDD把凸包的一个函数的int返回值写成了bool类型， 导致我俩查板子还查了好一会， 然后我就开始抄点积叉积乱七八糟的各种板子。 写完之后测了一下样例， 都过了， 交了一下wa2。大佬查了一下代码， 发现最后一条边跑不到， 改了一下并且控制了一下精度问题， 交了一发wa10！！ 这个时候只剩一个小时了， 我们三个一致觉得是精度问题， 开始疯狂考虑精度问题（赛后发现其实并不是， 而是少了一个特判！！） 各种改， 怎么改都是wa10， 如果几何题做得多的话其实应该可以意识到这不是精度问题的。 最后我们以四题结束了比赛， 晚上我补题的时候，我还觉着是精度的问题， 便重新写了一遍， 而且看了刘汝佳的蓝书和挑战程序设计白书的几何部分， 结果还是wa10！！ 一气之下我去看了安神的代码， 发现他们也wa10过， 我就看他们wa10前后两组的代码有什么不同， 发现在跑完凸包之后需要特判凸包里的点数如果&lt;=2的话 要输出0！ 我把这个条件加上去 就AC了！！！！ 把比赛时候写的第二发代码加上交上去 也AC了！！！ 所以根本就不是精度问题！ 就是自己考虑少了。。。 😭 总结：今天的比赛刚开始第一题签到题不太顺利， 比别人慢了许多， 之后的三题都是比较顺利的，不论是读题速度方便， 还是大佬想题和写题的速度都很快， 我们三个一起debug的时候意见也很统一， 就是最后的K题， 三个人一起跑偏了。。。 组队配合还需要多加练习。以后每场组队赛之后争取都写一下训练总结并把题补好， 为下学期区域赛做准备！]]></content>
      <categories>
        <category>训练总结</category>
      </categories>
      <tags>
        <tag>训练总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-划分树]]></title>
    <url>%2F2018%2F04%2F15%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%92%E5%88%86%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前两天在白书上学习了归并树， 是用了线段树+归并排序的思想在$O(log^3 (n))$复杂度下查找区间k大。 今天学习的划分树则可以在$O(log(n))$的复杂度下查找区间第k大。 划分树正好是归并树反过来了， 他用的是线段树+快速排序的思想。 快速排序我们先来复习快速排序的方法： 对于当前要排序的区间， 我们随机找一个数作为基础值， 分别用两个指针l和r 把基础值放在最左边。 r指针先往左移， 碰到一个比基础值小的a[r]， 交换a[r]和基础值， 让l往右移动， 直到碰到一个值[l]比基础值， 交换a[l]和基础值， 重复第二步， 直到l == r. 将基础值左边和右边的区间分别继续快速排序， 直到区间内只有一个值。 划分树划分树就是用线段树记录每一层快速排序的状态， 用sort快速排序作为辅助，将排好序的数组放到sorted[]内， 每次排序区间[l, r]时， 用sorted[(l+r)/2]作为基础值， 这样使得下一层左右两个区间尽长度尽可能相同。 我们用tree[20][n]来记录每一层快速排序的状态， 用toleft[dis][i]记录第dis层前i个值有多少个在下一层进入了左区间。 划分树也分为两部分： 1. 初始化操作对于每一个要排序的区间[l, r]， 将基础值设为sorted[(l+r)/2], 如果值小于基础值则放到下一层的左边， 否则放到下一层的右边区间， 但是这样不能保证左右区间尽可能长度相同， 主要是有很多个值都等于基础值， 这个时候就要将灵活处理一下： 用same记录当前和基础值相同的个数， same初始等于下一层左区间长度， 左区间每放一个小于等于基础值的数， same--， 直到same == 0 的时候， 剩下相等的就只能放到右边区间了。 最后顺便更新有多少个移到了下一层的左区间。 继续递归进行Build操作。 12345678910111213141516171819202122232425262728293031// 初始化区间[l,r]void Build(int dep, int l, int r) &#123; if(l == r) return; int mid = (l + r) &gt;&gt; 1; int same = mid - l + 1; for(int i = l; i &lt;= r; i++) if(tree[dep][i] &lt; sorted[mid]) same--; int lpos = l; int rpos = mid + 1; for(int i = l; i &lt;= r; i++) &#123; if(tree[dep][i] &lt; sorted[mid]) &#123;// 小的值直接放到左儿子 tree[dep + 1][lpos++] = tree[dep][i]; &#125; else if(tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0) &#123; // 左儿子还有空能放相同的数 tree[dep + 1][lpos++] = tree[dep][i]; same--; &#125; else tree[dep + 1][rpos++] = tree[dep][i]; // 剩下的大于等于的放到右儿子 toleft[dep][i] = toleft[dep][l - 1] + lpos - l; // 更新有多少个数放到了左边 &#125; Build(dep + 1, l, mid); Build(dep + 1, mid + 1, r);&#125;void Init() &#123; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); sorted[i] = tree[1][i] = a[i]; &#125; sort(sorted + 1, sorted + n + 1, cmp); Build(1, 1, n);&#125; 2. 查询操作查询[ql, qr]的第k大， 如果当前区间[l, r]下一层往左的个数即toleft[dep][qr]-toleft[dep][ql-1] &gt;= k的话， 说明第k大的数肯定在下一层的左区间， 并且更新查询区间。 newl为 当前的L + (L到ql中去了下一层左区间的个数， 他们不再查询范围内， 要加上）。 newr则为 newl + cnt - 1。 否则的话 说明第k大在下一层的右区间， 同理也需要更新查询区间。 继续查询。 newr为当前的qr 加上qr外面即（qr到R中到了下一层左边的个数）。 newl同理 newr就是往前（查询长度 - 要查询中去了下一层左边的个数）， 同时查询的个数也要减去cnt。 当区间只有一个值的时候， 为第k大， return即可。 1234567891011121314151617// 询问[ql, qr] 中第k大的数 // 外部调用query(1, 1, n, l, r, k);int query(int dep, int L, int R, int ql, int qr, int k) &#123; if(ql == qr) return tree[dep][ql]; int mid = (L + R) &gt;&gt; 1; int cnt = toleft[dep][qr] - toleft[dep][ql - 1]; if(cnt &gt;= k) &#123; int newl = L + toleft[dep][ql - 1] - toleft[dep][L - 1]; int newr = newl + cnt - 1; return query(dep + 1, L, mid, newl, newr, k); &#125; else &#123; int newr = qr + toleft[dep][R] - toleft[dep][qr]; int newl = newr - (qr - ql - cnt); return query(dep + 1, mid + 1, R, newl, newr, k - cnt); &#125;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-归并树]]></title>
    <url>%2F2018%2F04%2F11%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%BD%92%E5%B9%B6%E6%A0%91%2F</url>
    <content type="text"><![CDATA[用一句话定义归并树就是用线段树记录归并排序时每一层每一段数组的状态。 用途： 归并树可以在$O(log(n)^2 )$复杂度查找区间[l,r]比x小的有几个. 那么就可以通过二分枚举在$O(log(n)^3 )$复杂度实现查找区间[l,r]第k大的值. 我们先回顾一下归并排序的具体实现方法： 归并排序依靠递归的思想， 每次把当前要排序的区间分成尽可能相等的两部分， 左右两部分分别进行归并排序， 之后再将排好序的左右两个区间合并。 当区间长度为1的时候， 停止递归。 复杂度分析： 因为每次将当前序列分成两部分递归， 最多分$O(log(n))$层, 每层有n个元素, 所以归并排序的复杂度是$O(nlog(n))$. 归并排序最常用的就是求逆序对的个数， 其实用树状数组也可以在相同的复杂度下求出逆序对。 c++实现代码： 123456789101112131415161718192021//参考紫书算法竞赛入门经典 void merge_sort(int *A, int l, int r, int *T)&#123; //[l, r) 排序. 外部调用区间为[0, n) if(r - l &gt; 1)&#123; int mid = l+(r-l)/2; int p = l, q = mid, now = l; // 对左右两部分区间分别归并排序 merge_sort(A, l, mid, T); merge_sort(A, mid, r, T); // 合并左右两部分 while(p &lt; mid || q &lt; r)&#123; if(q &gt;= r || (p &lt; mid &amp;&amp; A[p] &lt;= A[q]))&#123; T[now++] = A[p++]; &#125; else&#123; T[now++] = A[q++]; cnt += mid - p; // cnt记录的是逆序对个数 &#125; &#125; for(int i = l; i &lt; r; i++) A[i] = T[i]; &#125;&#125; 以上是对归并排序的复习， 下面继续学习归并树。 先说一下归并树的大致思想， 用vector维护出每一个节点的区间[l,r)排完序之后的数组, 每次查询的时候, 分三种情况. 如果要查询的区间和当前的区间没有交集, 返回0个. 如果要查询的区间完全包含了当前的区间， 用二分搜索对于当前节点保存的数组进行查找。 负责的话递归左右儿子查找并且求和。 根据归并排序的思想， 要先初始化归并树， 原理同归并排序， 只不过把数组的值都存起来了， 每次询问的时候， 分上面说的三种情况就可以了。 具体看下面这一道例题以及模板代码。 模板例题： 2104 - K-th Number 123456789101112131415161718192021222324252627282930313233343536373839// 代码参考白书(挑战程序设计竞赛)const int MAXN = 1e5;const int ST_SIZE = (1 &lt;&lt; 18) - 1;int n, m;int a[MAXN+5], num[MAXN+5];// num用来存a排好序之后的数组， 方便二分vector&lt;int&gt; dat[ST_SIZE];// 初始化归并树， 原理和归并排序一样， 区间[l, r)void init(int k, int l, int r)&#123; if(r - l == 1)&#123; dat[k].push_back(a[l]); &#125; else&#123; int lch = k * 2 + 1, rch = k * 2 + 2; init(lch, l, (l+r)/2); init(rch, (l+r)/2, r); dat[k].resize(r-l); merge(dat[lch].begin(), dat[lch].end(), dat[rch].begin(), dat[rch].end(), dat[k].begin()); // 利用STL自带的merge函数把两个儿子的数列合并 &#125;&#125;// 计算[ql, qr) 中不超过x的个数// k是节点的编号, 对应区间[l, r)int query(int ql, int qr, int x, int k, int l, int r)&#123; if(qr &lt;= l || r &lt;= ql)&#123;//完全不相交 return 0; &#125; else if(ql &lt;= l &amp;&amp; r &lt;= qr)&#123; // 询问完全包含当前区间 return upper_bound(dat[k].begin(), dat[k].end(), x) - dat[k].begin(); &#125; else&#123; int lcnt = query(ql, qr, x, k*2+1, l, (l+r)/2); int rcnt = query(ql, qr, x, k*2+2, (l+r)/2, r); return lcnt + rcnt; &#125;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Mac中将chrome商店下载的插件导出为crx]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%9C%A8Mac%E4%B8%AD%E5%B0%86chrome%E5%95%86%E5%BA%97%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%8F%92%E4%BB%B6%E5%AF%BC%E5%87%BA%E4%B8%BAcrx%2F</url>
    <content type="text"><![CDATA[Mac下Chrome的插件保存在~/Library/Application\ Support/Google/Chrome/Default/Extensions/对应ID下。 通过下面两行命令我们可以看到每个插件的命名都是他固定的ID。 也就是在chrome浏览器中扩展程序里显示的ID。 12cd ~/Library/Application\ Support/Google/Chrome/Default/Extensions/ls 12cd 对应插件的IDls 这时候可以看到这个软件的版本， 再cd版本号 12cd 对应版本号pwd 使用pwd显示当前路径， 然后复制该路径。 粘贴到chrome-&gt;扩展程序-&gt;打包扩展程序。点击打包扩展程序这时候.xrc文件就会生成到对应目录下， 结束！]]></content>
      <categories>
        <category>Mac技巧</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>chrome插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[想把博客部署到Coding上? 看完再决定]]></title>
    <url>%2F2018%2F03%2F19%2F%E6%83%B3%E6%8A%8A%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0Coding%E4%B8%8A-%E7%9C%8B%E5%AE%8C%E5%86%8D%E5%86%B3%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[我想大多数人想把博客同时部署到Github和Coding上的目的基本都一样： 加快国内访问速度 能够被百度收录 我主要是奔着被百度收录进来的， 因为Github已经屏蔽了百度的爬虫， 所以想要被百度收录， 只好另寻他路， 网上有人说可以同时部署到gitcafe上， 可是一查， gitcafe早在2016年3月就被Coding并购了, 所以目前最好的办法就是同时部署到Github和Coding上了. 但是!! 但是!! Coding其实也坑的很. 首先Coding分为了四种会员:普通会员、银牌会员、金牌会员和钻石会员。 我想基本上每个人都使用了自己的域名了吧， 第一个坑点就是:你想绑定自己的域名, 必须是银牌会员。这个银牌会员是免费的， 只需要你完善个人信息就可以了。 但是你以为这样就结束了吗？ 并没有， 看官方的介绍说： 银牌会员是受限的pages自定义域名。 金牌及以上才是完全的自定义域名。我们来看看银牌是如何受限的： 银牌会员的 Coding Pages 在访问时默认会先加载 Pages 跳转页，您可选择在网站首页任意位置放置「Hosted by Coding Pages」的文字版或图片版，然后勾选下方的「已放置 Hosted by Coding Pages」选项，通过审核后您的 Pages 将不会显示跳转页。请务必将「Hosted by Coding Pages」持续保留在网站首页，撤掉后跳转页会再次出现。 意思就是说你使用自定义域名可以， 但是先帮我们弹一个页面， (打个广告). 这首先就影响了用户的体验， 并且， 百度爬虫也是爬不到的， 因为第一次访问到的是他的广告页面。并且最近(2018-3-19)我发现跳转的这个页面无法访问了， 所以每当第一次进入博客就会转到coding/404。之后再进一次就是正常的博客了， 但是你只要清除浏览器数据、缓存， 再次登录 又是404。体验更是糟糕。 我才猛的想起来前几天看了一些人的博客打开就是coding的404， 我以为是他们的博客不用了， 现在想想原来是coding搞的鬼。 当然coding显然意识到了这样体验实在是太差了， 当然有别的选择， 在你的博客上帮他打广告！ 只要你在博客首页放上coding要求的文字或者图片并且通过审核， 就可以不用页面跳转了。 我今天刚刚提交申请， 说是在两个工作日完成审核。 我文字放在了最下面： 第二天更新：我是昨天下午提交审核的， 今天早晨下课一看已经通过审核了。 可以通过Coding正常访问了， 不会跳出中转页面。 紧接着我就去阿里云设置dns， 将github的设置为境外， coding为默认。 然后去了站长工具dns检测 。 可以看出大陆的都是通过coding访问的， 国外的是通过github访问的。 当然我最关心的问题还是百度收录的问题，去百度平台看了一下， 发现之前提交的站点地图在昨晚11点半的时候竟然有抓取记录， 不懂这是在干嘛， 百度搜了一下我的域名还是搜不到， 又去抓取诊断里试了一下， 咦！ 竟然能被抓取到了。但是试了几次不是百分百成功。 网上都说被百度收录是一个漫长的过程， 那我就先慢慢等待。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客遇到的坑]]></title>
    <url>%2F2018%2F03%2F11%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[待解决问题首页预览行数控制问题。配置第三方服务。 （评论， 数量统计之类的)是否能把csdn的博客迁过来。 （不打算搬了， 分开写不同的东西）about页面的一些美化让百度google能够搜索 （谷歌已经解决， 百度貌似被github屏蔽了）每一篇文章阅读量多台电脑管理博客， 参考博客共同管理站点让文章可以置顶 已解决问题 侧栏链接图标配不上去问题&#160; &#160; 教程中说的是 在主题配置文件中的social_icons中添加网站的名称, 但是试了很多次都不成功.&#160; &#160; 解决办法: 发现在social也就是贴链接的位置 后面默认会有两个竖杠|| , 正确做法是在||后面粘贴图片的名字. 12345social: GitHub: https://github.com/ZZZZone || github 微博: http://weibo.com/_ZZZZone || weibo 知乎: http://www.zhihu.com/people/zzzzone-87 || bolt codeforces: http://codeforces.com/profile/ZZZZone || fort-awesome mathjax渲染问题更新， 请不要使用删除线中的方法 &#160; &#160; 网上找了很多方法, 不停地uninstall,install, 已经忘记了hexo默认给的是什么软件渲染的了.&#160; &#160; 最后使用的是markdown-it, 虽然在next主题的TOC显示上面会有一些问题, 牺牲一下吧. 毕竟写题解的时候公式很重要。 暂时先使用这种方法。markdown-it &#160; &#160; 之前一直使用的是markdown-it, 问题就是TOC有问题并且在主页无法使用&lt;!-- more --&gt;来设置阅读全文.&#160; &#160; 解决方法: 经过一番搜索, 发现了另一个软件, 叫hexo-renderer-kramed，完美解决了这个问题。参考博客: 林肯先生的blog。 具体做法这篇博客已经详细介绍了。 评论插件在尝试了gitment和来必力之后, 我选择了来必力. 使用比较简单， 因为gitment我没有解决issue过长导致异常的问题。 而且gitment只能使用github账号登陆， 对于我这种基本没有评论的人来说被评论的机会就更小了， 所以最终选择了来必力。使用法法: 在来必力官网注册一下， 因为我是用的是next5.1.4版本， 配置中已经集成了许多插件， 不需要自己再去修改文件了， 只求要去改一改配置就行了。 在主题目录中的配置文件搜索livere_uid: 在这里填上你申请的来必力代码中有一串ID， 就可以了。 更新： 把来必力换掉了。 换成Valine了， 更简约， 使用起来更方便。 使用的跟文章浏览人数同样的管理平台， 数据管理起来也比较方便。 可以到next主题目录下的配置文件中的valine写好对应的id和key就可以了。 具体教程参考： valine官方文档 文章阅读量显示这个很好弄， 照着教程解决就可以了链接在此 使用自己的域名在阿里云上1块钱一年的.top域名。 觉得很实惠， 就买了一个。 按照百度上的做法配置了域名之后， 发现只能用chrome浏览器访问， 手机和电脑都是。 电脑用Safari找不到服务器， 手机用了via浏览器一直显示dnserror， 百度了一下说是DNS劫持？ 果断把电脑了DNS从114.114.114.114换回了默认， 手机浏览器清了一下cookie什么的， 解决。 所有浏览器正常访问。 博文置顶🔝github上有这样的仓库了，原仓库替换了hexo自带的置顶， 挺好用的。 执行下面两行命令： 12$ npm uninstall hexo-generator-index --save $ npm install hexo-generator-index-pin-top --save 之后只需要在文章的front-matter中添加top: ture就可以将博文置顶了。后来我又发现， 使用top: 数值 会按数值降序置顶排序。 next主题支持在front-matter中添加sticky: true来显示置顶标志（一个小Pin）。 将博客部署到coding 上参考博客Hexo博客部署到GitHub和Coding我部署到coding上主要是为了解决百度无法爬去github。首先是在coding上注册账号， 然后创建一个工程， 工程名称和你的用户名一样， 避免css之后渲染出问题。给coding配置ssh秘钥。 在终端中执行ssh -T git@git.coding.net 检验是否配置成功。然后在站点的配置文件 _config.yml 中添加coding的ssh路径. 仿照github中的方法配置。然后执行 三命令， 就可以将博客部署到coding上。去阿里云修改dsn解析。 将之前github的dsn 修改为海外 。 然后再添加coding。最后再去coding的仓库pages服务， 添加静态pages。 并添加自定义域名。 我手动添加了zzzzone.top和www.zzzzone.top两个域名。 最后我在/Users/zong/Documents/hexo/themes/next/layout/_partials中]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
